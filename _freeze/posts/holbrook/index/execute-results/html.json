{
  "hash": "5296ca4483283d8eaea087674cabc50a",
  "result": {
    "markdown": "---\ntitle: \"Estimating sea trout smolt migration risks\"\nsubtitle: \"Analysis code for a simple state-space model to estimate acoustically tagged sea trout migration risks\"\ndate: \"2016-01-28\"\ncategories: [\"tagging-and-telemetry\", \"statistics\", \"code\"]\n# tags: ['Bayesian', 'Bayesian State Space', 'Imperfect detection', 'Probability', 'Sea trout', 'Statistics', 'Transition probability']\nimage: \"tracking_sea_trout.jpg\"\nimage-alt: \"Sea trout with tags\"\nfilters:\n   - lightbox\nlightbox: auto\n---\n\n\nI'm involved with a project aiming to understand brown trout (*Salmo trutta* L.) movements in freshwater and estuarine environments.\n\nHere, I want to share the methods we used to estimate the risks to brown trout when they migrate as sea trout smolts.\n\nBut first a little background.\n\n# Background\n\nBrown trout are funny fish.\n\nSome spend their entire lives in freshwater, e.g., a river, and are known as *brown trout*. Others migrate to marine waters, e.g., an estuary or sea, and are known as *sea trout*.\n\nSea trout return to freshwater a lot larger than brown trout, after feasting on the abundant food available in marine waters, and are able to produce more eggs. Brown trout might be smaller but they don't run the risk of being eaten by any of the abundant marine predators.\n\nClearly, there is a fitness trade-off between getting big & producing more eggs (maximise your potential reproduction) and avoiding being eaten by any one of the abundant marine predators (maximise your potential survival to reproduction).\n\nThe decision to migrate is not, however, black and white. *Finnock* are brown trout that use estuaries and transitional waters for only short periods, e.g., a couple of months, presumably to feed.\n\nSo which strategy is best: brown trout, finnock or sea trout?\n\nTo study this question, we estimated the risk to sea trout of migrating through fresh, transitional and estuarine waters.\n\nTo estimate these risks, we acoustically tagged a sample of migrating sea trout smolts who's migration pathways were recorded at listening receivers located in the different zones (Figure 1).\n\n![Location of listening receivers in Poole Harbour. Red dots represent approximate detection range of the receivers.](map1.png)\n\n# Analysis methods\n\nAcoustic tracking data has the problem that *detection is imperfect*; we do not always detect a passing tag and so we don't know if (i) the tag didn't pass or (ii) whether it passed but was not detected.\n\nThis problem can and *should* be addressed statistically.\n\nTo estimate the risks to sea trout smolt of migrating through different zones, we used Bayesian State Space models ([wikipedia: State-space representation](https://en.wikipedia.org/wiki/State-space_representation)).\n\nI was reassured that others have used BSSMs in this context: Oliviez Gimenez's [paper](http://dx.doi.org/10.1016/j.ecolmodel.2007.03.040) explains clearly the theory of BSSMs for marked individuals and Chris Holbrook's [paper](http://dx.doi.org/10.1139/cjfas-2013-0581) was an illustrative example of BSSM implementation for acoustically tagged lamprey.\n\nIn essence, BSSM estimates jointly the probability that a tag is detected at a particular location and the probability that it made the transition to that location successfully.\n\nIn our study, we assumed that all individuals shared the same detection and transition probabilities, i.e., that physical or behavioural differences between individuals were unimportant, and that individuals travelled independently.\n\nWe could therefore use the simple Cormack, Jolly & Seber (CJS) model given by:\n\n$$\nY_t|X_t \\sim Binomial(X_t − u_t, p_t)\n$$\n\n$$\nX_{t+1}|X_t \\sim Binomial(X_t, \\phi_t) + u_{t+1}\n$$\n\nwhere $X_t$ is the total number of survivors from time $t$, which includes $u_t$ that is the number of newly marked individuals at time $t$, $Y_t$ is the total number of previously marked individuals encountered at time $t$, $p_t$ is the probability of detecting a tagged individual at time $t$ ($t = 2, ..., T$) and $\\phi_t$ is the probability that a tagged individual transitions to time $t + 1$ given that it is alive at time $t$ ($t = 1, ..., T − 1$).\n\nThis formulation separates the nuisance parameters (the detection probabilities, $p_t$) from the parameters of interest (the transition probabilities, $\\phi_t$) because the latter are found only in the second or \"state\" equation.\n\nUsing this model, we estimated values of $p_t$ and $\\phi_t$ using the Monte Carlo Markov Chain (MCMC) method in [JAGS](http://mcmc-jags.sourceforge.net). [JAGS](http://mcmc-jags.sourceforge.net) uses Gibbs sampling to explore the joint probability distribution of $p_t$ and $\\phi_t$. Through an iterative process, weakly informative $Beta(1, 1)$ prior distributions on $p_t$ and $\\phi_t$ were updated with increasingly credible values until, after sufficient iterations, the best estimated values of $p_t$ and $\\phi_t$ were taken to be the median of their posterior distributions.\n\nWe ran [JAGS](http://mcmc-jags.sourceforge.net) from within [R](http://www.r-project.org) using functions from package [dclone](https://cran.r-project.org/package=dclone). We ran three MCMC chains for 30,000 iterations, of which we discarded the first 10,000 as burnin.\n\n[R](http://r-project.org) code to run an example BSSM is as follows:\n\nThe [JAGS](http://mcmc-jags.sourceforge.net) model file for the example might be `BSSM.jags`:\n\n\n::: {.cell messages='false' warnings='false' hash='index_cache/html/unnamed-chunk-1_91610d366e77cac81758e9449df664ce'}\n\n```{.r .cell-code}\n# simulate data\nreceivor_efficiencies <- c('r1' = 0.8, 'r2' = 0.9, 'r3' = 0.6, 'r4' = 0.7, 'r5' = 0.7, 'r6' = 0.7)\nn_fish <- 77\nch_m <- matrix(NA, ncol = length(receivor_efficiencies), nrow = n_fish)\nfor(i in 1:length(receivor_efficiencies)){\n    ch_m[, i] <- sample(c(0, 1), n_fish, TRUE, c((1 - receivor_efficiencies[i]), receivor_efficiencies[i]))\n}\nch_m <- data.frame('release' = 1, ch_m)\ncolnames(ch_m)[-1] <- names(receivor_efficiencies)\n\n# create state and observation matrices\nsm <- ch_m\nsm[sm == '0'] <- NA\nom <- ch_m\n\n# prep data\nd <- list('sm' = sm,\n          'om' = om,\n          'N' = n_fish,\n          'T' = ncol(ch_m))\n\n# load libraries\nlibrary(dclone)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: coda\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: parallel\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Matrix\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ndclone 2.3-0 \t 2019-03-21\n```\n:::\n\n```{.r .cell-code}\nlibrary(rjags)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLinked to JAGS 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoaded modules: basemod,bugs\n```\n:::\n\n```{.r .cell-code}\n# name of model file\nmf <- function() {\n\n  # define likelihoods\n  for(i in 1:N){\n    for(t in 2:T){\n\n      # state model\n      sm[i, t] ~ dcat(phi[t - 1, sm[i, t - 1], ])\n\n      # observation model\n      om[i, t] ~ dbern(p[t, sm[i, t]])\n\n    }\n  }\n\n  # detection probability priors and constraints\n\n  # release\n  p[1, 1] <- 1 # always observed at release\n  p[1, 2] <- 0\n\n  # r1\n  p[2, 1] ~ dbeta(1, 1) # flat prior\n  p[2, 2] <- 0\n\n  # r2\n  p[3, 1] ~ dbeta(1, 1) # flat prior\n  p[3, 2] <- 0\n\n  # r3\n  p[4, 1] ~ dbeta(1, 1) # flat prior\n  p[4, 2] <- 0\n\n  # r4\n  p[5, 1] ~ dbeta(1, 1) # flat prior\n  p[5, 2] <- 0\n\n  # r5\n  p[6, 1] ~ dbeta(1, 1) # flat prior\n  p[6, 2] <- 0\n\n  # r6\n  p[7, 1] ~ dbeta(1, 1) # flat prior\n  p[7, 2] <- 0\n\n  # transition probability priors and constraints\n\n  # 1st transition\n  phi[1, 1, 1] ~ dbeta(1, 1)\n  phi[1, 1, 2] <- 1 - phi[1, 1, 1]\n  phi[1, 2, 1] <- 0\n  phi[1, 2, 2] <- 1\n\n  # 2nd transition\n  phi[2, 1, 1] ~ dbeta(1, 1)\n  phi[2, 1, 2] <- 1 - phi[2, 1, 1]\n  phi[2, 2, 1] <- 0\n  phi[2, 2, 2] <- 1\n\n  # 3rd transition\n  phi[3, 1, 1] ~ dbeta(1, 1)\n  phi[3, 1, 2] <- 1 - phi[3, 1, 1]\n  phi[3, 2, 1] <- 0\n  phi[3, 2, 2] <- 1\n\n  # 4th transition\n  phi[4, 1, 1] ~ dbeta(1, 1)\n  phi[4, 1, 2] <- 1 - phi[4, 1, 1]\n  phi[4, 2, 1] <- 0\n  phi[4, 2, 2] <- 1\n\n  # 5th transition\n  phi[5, 1, 1] ~ dbeta(1, 1)\n  phi[5, 1, 2] <- 1 - phi[5, 1, 1]\n  phi[5, 2, 1] <- 0\n  phi[5, 2, 2] <- 1\n\n  # 6th transition\n  phi[6, 1, 1] ~ dbeta(1, 1)\n  phi[6, 1, 2] <- 1 - phi[6, 1, 1]\n  phi[6, 2, 1] <- 0\n  phi[6, 2, 2] <- 1\n\n}\n\n# parameters to monitor\np <- c('p', 'phi')\n\n# initialise model\nm <- jagsModel(mf, data = d, n.chains = 1, n.adapt = 1000, quiet = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRegistered S3 method overwritten by 'R2WinBUGS':\n  method            from  \n  as.mcmc.list.bugs dclone\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nCompiling model graph\n   Resolving undeclared variables\n   Allocating nodes\nGraph information:\n   Observed stochastic nodes: 800\n   Unobserved stochastic nodes: 136\n   Total graph size: 1331\n\nInitializing model\n```\n:::\n\n```{.r .cell-code}\nupdate(m, n.iter = 10000)\n\n# coda samples\ns <- codaSamples(m, p, n.iter = 20000)\n\n# plot traces\nplot(s, trace = TRUE, density = FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-5.png){width=672}\n:::\n\n```{.r .cell-code}\n# plot densities\nplot(s, trace = FALSE, density = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-6.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-7.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-8.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-9.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-10.png){width=672}\n:::\n\n```{.r .cell-code}\n# summary\ns.tab <- summary(s)\nprint(s.tab$statistics, digits = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Mean     SD Naive SE Time-series SE\np[1,1]     1.0000 0.0000 0.00e+00       0.000000\np[2,1]     0.8226 0.0424 3.00e-04       0.000295\np[3,1]     0.8989 0.0336 2.37e-04       0.000237\np[4,1]     0.5384 0.0571 4.04e-04       0.000404\np[5,1]     0.7078 0.0523 3.70e-04       0.000403\np[6,1]     0.8134 0.0488 3.45e-04       0.000550\np[7,1]     0.8130 0.1059 7.49e-04       0.003669\np[1,2]     0.0000 0.0000 0.00e+00       0.000000\np[2,2]     0.0000 0.0000 0.00e+00       0.000000\np[3,2]     0.0000 0.0000 0.00e+00       0.000000\np[4,2]     0.0000 0.0000 0.00e+00       0.000000\np[5,2]     0.0000 0.0000 0.00e+00       0.000000\np[6,2]     0.0000 0.0000 0.00e+00       0.000000\np[7,2]     0.0000 0.0000 0.00e+00       0.000000\nphi[1,1,1] 0.9872 0.0126 8.93e-05       0.000211\nphi[2,1,1] 0.9872 0.0125 8.87e-05       0.000211\nphi[3,1,1] 0.9749 0.0201 1.42e-04       0.000332\nphi[4,1,1] 0.9829 0.0162 1.14e-04       0.000273\nphi[5,1,1] 0.9525 0.0340 2.40e-04       0.000671\nphi[6,1,1] 0.8180 0.1051 7.44e-04       0.003848\nphi[1,2,1] 0.0000 0.0000 0.00e+00       0.000000\nphi[2,2,1] 0.0000 0.0000 0.00e+00       0.000000\nphi[3,2,1] 0.0000 0.0000 0.00e+00       0.000000\nphi[4,2,1] 0.0000 0.0000 0.00e+00       0.000000\nphi[5,2,1] 0.0000 0.0000 0.00e+00       0.000000\nphi[6,2,1] 0.0000 0.0000 0.00e+00       0.000000\nphi[1,1,2] 0.0128 0.0126 8.93e-05       0.000211\nphi[2,1,2] 0.0128 0.0125 8.87e-05       0.000211\nphi[3,1,2] 0.0251 0.0201 1.42e-04       0.000332\nphi[4,1,2] 0.0171 0.0162 1.14e-04       0.000273\nphi[5,1,2] 0.0475 0.0340 2.40e-04       0.000671\nphi[6,1,2] 0.1820 0.1051 7.44e-04       0.003848\nphi[1,2,2] 1.0000 0.0000 0.00e+00       0.000000\nphi[2,2,2] 1.0000 0.0000 0.00e+00       0.000000\nphi[3,2,2] 1.0000 0.0000 0.00e+00       0.000000\nphi[4,2,2] 1.0000 0.0000 0.00e+00       0.000000\nphi[5,2,2] 1.0000 0.0000 0.00e+00       0.000000\nphi[6,2,2] 1.0000 0.0000 0.00e+00       0.000000\n```\n:::\n:::\n\n\nwhere `d` is a list of data passed to [JAGS](http://mcmc-jags.sourceforge.net) that includes:\n\n-   $N$ = number of individuals\n-   $T$ = number of occasions\n-   $sm[i, t]$ = true state matrix\n-   $om[i, t]$ = observation matrix\n\nwhere $i$ is individual and $t$ is occasion.\n\nOur model ran without problems and the results were intuitive and as expected. We feel that this procedure worked well for us.\n\nYou will be able to read about the results in a future post.\n\nIn the meantime, use the code above to run an example BSSM and contact me if you have any problems.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}